diff --git a/block/vhdx.c b/block/vhdx.c
index 5aa1a13506..d619c3cfa5 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@ vhdx_co_create(BlockdevCreateOptions *opts, Error **errp)
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Samsung v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
index 8ffe8b3b9b..8a86e4790e 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1177,7 +1177,7 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "Samnsung VVFAT", 10);
     }
 
     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
index 2279694cfa..2a00afe6f7 100644
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Chardev *s, const uint8_t *buf, int len)
 }
 
 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Razer USA, Ltd Razer DeathAdder V3 Pro",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
index f4008bf35b..d32ec39550 100644
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceState *dev)
 }
 
 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Co., Ltd CTL-472 [One by Wacom (S)]",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/50-qemu-gpu.json.in b/contrib/vhost-user-gpu/50-qemu-gpu.json.in
index f5edd097f8..40f1470c1f 100644
--- a/contrib/vhost-user-gpu/50-qemu-gpu.json.in
+++ b/contrib/vhost-user-gpu/50-qemu-gpu.json.in
@@ -1,5 +1,5 @@
 {
-  "description": "QEMU vhost-user-gpu",
+  "description": "ASUS vhost-user-gpu",
   "type": "gpu",
   "binary": "@libexecdir@/vhost-user-gpu"
 }
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
index bb41758e34..9f778f3adb 100644
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("ASUS vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/docs/interop/vhost-user.json b/docs/interop/vhost-user.json
index b6ade9e493..e7a131e791 100644
--- a/docs/interop/vhost-user.json
+++ b/docs/interop/vhost-user.json
@@ -246,7 +246,7 @@
 # Example:
 #
 # {
-#   "description": "QEMU vhost-user-gpu",
+#   "description": "ASUS vhost-user-gpu",
 #   "type": "gpu",
 #   "binary": "/usr/libexec/qemu/vhost-user-gpu",
 #   "tags": [
diff --git a/docs/specs/fw_cfg.rst b/docs/specs/fw_cfg.rst
index 5ad47a901c..8a4475c3d7 100644
--- a/docs/specs/fw_cfg.rst
+++ b/docs/specs/fw_cfg.rst
@@ -97,7 +97,7 @@ Arm
 ACPI Interface
 --------------
 
-The fw_cfg device is defined with ACPI ID ``QEMU0002``. Since we expect
+The fw_cfg device is defined with ACPI ID ``ASUS0002``. Since we expect
 ACPI tables to be passed into the guest through the fw_cfg device itself,
 the guest-side firmware can not use ACPI to find fw_cfg. However, once the
 firmware is finished setting up ACPI tables and hands control over to the
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 6d4517cfbe..ead9216382 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -2251,7 +2251,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "MSOFT", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/arm/nseries.c b/hw/arm/nseries.c
index 35364312c7..aa6928bf12 100644
--- a/hw/arm/nseries.c
+++ b/hw/arm/nseries.c
@@ -849,7 +849,7 @@ static void n800_setup_nolo_tags(void *sram_base)
 
     memset(p, 0, 0x3000);
 
-    strcpy((void *) (p + 0), "QEMU N800");
+    strcpy((void *) (p + 0), "ASUS N800");
 
     strcpy((void *) (p + 8), "F5");
 
diff --git a/hw/char/escc.c b/hw/char/escc.c
index d450d70eda..77a726a362 100644
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void escc_realize(DeviceState *dev, Error **errp)
 
     if (s->chn[0].type == escc_mouse) {
         qemu_add_mouse_event_handler(sunmouse_event, &s->chn[0], 0,
-                                     "QEMU Sun Mouse");
+                                     "ASUSTek Computer, Inc. Sun Mouse");
     }
     if (s->chn[1].type == escc_kbd) {
         s->chn[1].hs = qemu_input_handler_register((DeviceState *)(&s->chn[1]),
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb819675e..7b41abae01 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -394,16 +394,16 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "SAM";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "SAMSUNG Odyssey G65B";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 2560;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1440;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,7 +449,7 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0xA05F;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
diff --git a/hw/i2c/exynos4210_i2c.c b/hw/i2c/exynos4210_i2c.c
index 9445424d5f..7079fb633e 100644
--- a/hw/i2c/exynos4210_i2c.c
+++ b/hw/i2c/exynos4210_i2c.c
@@ -59,7 +59,7 @@ OBJECT_DECLARE_SIMPLE_TYPE(Exynos4210I2CState, EXYNOS4_I2C)
 
 #if EXYNOS4_I2C_DEBUG
 #define DPRINT(fmt, args...)              \
-    do { fprintf(stderr, "QEMU I2C: "fmt, ## args); } while (0)
+    do { fprintf(stderr, "Gigabyte I2C: "fmt, ## args); } while (0)
 
 static const char *exynos4_i2c_get_regname(unsigned offset)
 {
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 5d4bd2b710..23f536d47f 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -2651,6 +2651,14 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
         g_array_append_vals(tables_blob, u, len);
     }
 
+    /* Disable BGRT (UEFI Logo)*/
+    acpi_add_table(table_offsets, tables_blob);
+    AcpiTable table = { .sig = "BGRT", .rev = 1,
+                        .oem_id = x86ms->oem_id, .oem_table_id = x86ms->oem_table_id };
+    acpi_table_begin(&table, tables_blob);
+    build_append_int_noprefix(tables_blob,0x00000000,4);
+    acpi_table_end(tables->linker, &table);
+
     /* RSDT is pointed to by RSDP */
     rsdt = tables_blob->len;
     build_rsdt(tables_blob, tables->linker, table_offsets,
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 0e4494627c..63000fd03a 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -73,7 +73,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("American Megatrends International, LLC.", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -226,7 +226,7 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     Aml *dev = aml_device("FWCF");
     Aml *crs = aml_resource_template();
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("ASUS0002")));
 
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index a527c0df0a..fe73fc155e 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -75,9 +75,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "AMD vCPU" v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "AMD vCPU " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "AMD vCPU " v, },
 
 GlobalProperty pc_compat_9_0[] = {
     { TYPE_X86_CPU, "x-amd-topoext-features-only", "false" },
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index e82959dc2d..78a9e9b19f 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "SAMSUNG");
+        padstr8(buf + 16, 16, "Samsung TS-H353B SATA DVD-ROM Drive");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index 08d9218455..f0903962e0 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2640,20 +2640,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
         snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+                  "SAM%05d", s->drive_serial);
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "Samsung TS-H353B SATA DVD-ROM Drive");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Sony MicroDrive Reader");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 990 PRO 2TB");
             break;
         }
     }
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
index 758fa6d267..073b854b38 100644
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *dev)
 }
 
 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ASUSTek Computer, Inc. ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/ads7846.c b/hw/input/ads7846.c
index cde3892216..52540342b6 100644
--- a/hw/input/ads7846.c
+++ b/hw/input/ads7846.c
@@ -154,7 +154,7 @@ static void ads7846_realize(SSIPeripheral *d, Error **errp)
 
     /* We want absolute coordinates */
     qemu_add_mouse_event_handler(ads7846_ts_event, s, 1,
-                    "QEMU ADS7846-driven Touchscreen");
+                    "ASUSTek Computer, Inc. ADS7846-driven Touchscreen");
 
     ads7846_int_update(s);
 
diff --git a/hw/input/hid.c b/hw/input/hid.c
index 76bedc1844..74ac32cc4a 100644
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "ASUSTek Computer, Inc. HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "ASUSTek Computer, Inc. HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "ASUSTek Computer, Inc. HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
index d6f834443d..192326b311 100644
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_ps2_mouse = {
 };
 
 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "ASUSTek Computer, Inc. PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState *dev, Error **errp)
 }
 
 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "ASUSTek Computer, Inc. PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/tsc2005.c b/hw/input/tsc2005.c
index 54a15d2441..33666ffb80 100644
--- a/hw/input/tsc2005.c
+++ b/hw/input/tsc2005.c
@@ -523,7 +523,7 @@ void *tsc2005_init(qemu_irq pintdav)
     tsc2005_reset(s);
 
     qemu_add_mouse_event_handler(tsc2005_touchscreen_event, s, 1,
-                    "QEMU TSC2005-driven Touchscreen");
+                    "ASUSTek Computer, Inc. TSC2005-driven Touchscreen");
 
     qemu_register_reset((void *) tsc2005_reset, s);
     vmstate_register(NULL, 0, &vmstate_tsc2005, s);
diff --git a/hw/input/tsc210x.c b/hw/input/tsc210x.c
index c4e32c7a42..96a51122a4 100644
--- a/hw/input/tsc210x.c
+++ b/hw/input/tsc210x.c
@@ -1122,7 +1122,7 @@ uWireSlave *tsc2102_init(qemu_irq pint)
     s->model = 0x2102;
     s->name = "tsc2102";
 
-    tsc210x_init(s, "QEMU TSC2102-driven Touchscreen", &vmstate_tsc2102);
+    tsc210x_init(s, "ASUSTek Computer, Inc. TSC2102-driven Touchscreen", &vmstate_tsc2102);
 
     return &s->chip;
 }
@@ -1143,7 +1143,7 @@ uWireSlave *tsc2301_init(qemu_irq penirq, qemu_irq kbirq, qemu_irq dav)
     s->model = 0x2301;
     s->name = "tsc2301";
 
-    tsc210x_init(s, "QEMU TSC2301-driven Touchscreen", &vmstate_tsc2301);
+    tsc210x_init(s, "ASUSTek Computer, Inc. TSC2301-driven Touchscreen", &vmstate_tsc2301);
 
     return &s->chip;
 }
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
index 45e4d4c75d..f3207f673d 100644
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Razer USA, Ltd Razer Huntsman Mini"
+#define VIRTIO_ID_NAME_MOUSE        "Razer USA, Ltd Razer DeathAdder V3 Pro"
+#define VIRTIO_ID_NAME_TABLET       "Razer USA, Ltd Razer Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "Razer USA, Ltd Razer MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index fe822f63b3..16ce01bed2 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8472,7 +8472,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "SAMSUNG", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 58cdcd3121..772472b9e1 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("ASUS0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index fc0263f349..174bfe450e 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -57,7 +57,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x4153532520444647ULL /* "QEMU CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index e9cf455bf5..5861fd6f2a 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -219,7 +219,7 @@ static void gpex_root_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Gigabyte PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/scsi/megasas.c b/hw/scsi/megasas.c
index 2d0c607177..bbb3b84ee5 100644
--- a/hw/scsi/megasas.c
+++ b/hw/scsi/megasas.c
@@ -48,7 +48,7 @@
 #define MEGASAS_MAX_SECTORS 0xFFFF      /* No real limit */
 #define MEGASAS_MAX_ARRAYS 128
 
-#define MEGASAS_HBA_SERIAL "QEMU123456"
+#define MEGASAS_HBA_SERIAL "SAMSUNG123"
 #define NAA_LOCALLY_ASSIGNED_ID 0x3ULL
 #define IEEE_COMPANY_LOCALLY_ASSIGNED 0x525400
 
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f39fa..875a021874 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s11s4s51s41s91",
+                              "SAMSUNG MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "SAMSUNG MPT Fusion",
+                              "SAMSUNG",
+                              "1145143919810000");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 53eff5dd3d..6327802fdd 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -652,8 +652,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "ASUS    ", 8);
+        memcpy(&r->buf[16], "ASUS TARGET     ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index 4d94b2b816..ec511a9f1e 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2559,7 +2559,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("SAMSUNG");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2623,7 +2623,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 990 PRO 2TB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2650,7 +2650,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("Samsung TS-H353B SATA DVD-ROM Drive");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
index c75a6c8807..ef87ac628e 100644
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "ASUS EMPTY      ", 16);
+    memcpy(&resp_data[8], "ASUS    ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
diff --git a/hw/sd/sd.c b/hw/sd/sd.c
index a639ff674c..6c9ba7f7f2 100644
--- a/hw/sd/sd.c
+++ b/hw/sd/sd.c
@@ -440,7 +440,7 @@ static void sd_set_scr(SDState *sd)
 
 #define MID     0xaa
 #define OID     "XY"
-#define PNM     "QEMU!"
+#define PNM     "SAM!"
 #define PRV     0x01
 #define MDT_YR  2006
 #define MDT_MON 2
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index a394514264..aff23012c7 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -573,7 +573,7 @@ static void smbios_build_type_0_table(void)
 
     t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
     t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_characteristics_extension_bytes[1] = 0x08; /* TCD/SVVP | VM */
     if (smbios_type0.uefi) {
         t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
     }
@@ -694,15 +694,15 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
         t->processor_id[1] = cpu_to_le32(type4.processor_id >> 32);
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
-    t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->voltage = 0x8B;
+    t->external_clock = cpu_to_le16(100); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
     t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->l1_cache_handle = cpu_to_le16(0x0039); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x003A); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x003B); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -715,7 +715,7 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
 
     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;
 
-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
+    t->processor_characteristics = cpu_to_le16(0x04); /* Unknown */
     t->processor_family2 = cpu_to_le16(type4.processor_family);
 
     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
@@ -843,9 +843,9 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* Other */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -872,8 +872,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(64); /* Unknown */
+    t->data_width = cpu_to_le16(64); /* Unknown */
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -888,7 +888,7 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
+    t->memory_type = 0x1A; /* RAM */
     t->type_detail = cpu_to_le16(0x02); /* Other */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
@@ -897,9 +897,9 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
     t->attributes = 0; /* Unknown */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    t->minimum_voltage = cpu_to_le16(1200); /* Unknown */
+    t->maximum_voltage = cpu_to_le16(1350); /* Unknown */
+    t->configured_voltage = cpu_to_le16(1200); /* Unknown */
 
     SMBIOS_BUILD_TABLE_POST;
 }
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 81bfff9b4e..7615fc1e9f 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSIO", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index b306eeb20e..da590727ba 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "JTU72VDVWE"
 };
 
 static const USBDescDevice desc_device_canokey = {
@@ -306,7 +306,7 @@ static void canokey_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "CanoKey QEMU";
+    uc->product_desc   = "CanoKey";
     uc->usb_desc       = &desc_canokey;
     uc->handle_reset   = canokey_handle_reset;
     uc->handle_control = canokey_handle_control;
@@ -314,7 +314,7 @@ static void canokey_class_init(ObjectClass *klass, void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = canokey_realize;
     uc->unrealize      = canokey_unrealize;
-    dc->desc           = "CanoKey QEMU";
+    dc->desc           = "CanoKey";
     device_class_set_props(dc, canokey_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
 }
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 1897fff9e6..cdf1805b00 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -40,8 +40,8 @@
 
 static void usb_audio_reinit(USBDevice *dev, unsigned channels);
 
-#define USBAUDIO_VENDOR_NUM     0x46f4 /* CRC16() of "QEMU" */
-#define USBAUDIO_PRODUCT_NUM    0x0002
+#define USBAUDIO_VENDOR_NUM     0x1038 /* CRC16() of "SteelSeries ApS" */
+#define USBAUDIO_PRODUCT_NUM    0x12b3
 
 #define DEV_CONFIG_VALUE        1 /* The one and only */
 
@@ -73,8 +73,8 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
+    [STRING_MANUFACTURER]       = "SteelSeries ApS",
+    [STRING_PRODUCT]            = "SteelSeries Arctis 1 Wireless",
     [STRING_SERIALNUMBER]       = "1",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
@@ -1006,7 +1006,7 @@ static void usb_audio_class_init(ObjectClass *klass, void *data)
     dc->vmsd          = &vmstate_usb_audio;
     device_class_set_props(dc, usb_audio_properties);
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
-    k->product_desc   = "QEMU USB Audio Interface";
+    k->product_desc   = "SteelSeries ApS SteelSeries Arctis 1 Wireless";
     k->realize        = usb_audio_realize;
     k->handle_reset   = usb_audio_handle_reset;
     k->handle_control = usb_audio_handle_control;
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 9e358c934e..9ab49a3942 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
+    [STR_MANUFACTURER]     = "Razer USA, Ltd",
+    [STR_PRODUCT_MOUSE]    = "Razer DeathAdder V3 Pro",
+    [STR_PRODUCT_TABLET]   = "Razer Tablet",
+    [STR_PRODUCT_KEYBOARD] = "Razer Huntsman Mini",
     [STR_SERIAL_COMPAT]    = "42",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "BSGMMXHEP7",
+    [STR_SERIAL_TABLET]    = "ERYV8E95VE",
+    [STR_SERIAL_KEYBOARD]  = "FVVBDBHDBN",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -806,7 +806,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "Razer Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -829,7 +829,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "Razer USA, Ltd Razer DeathAdder V3 Pro";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -853,7 +853,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "Razer USA, Ltd Razer Huntsman Mini";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index 2c3640c705..6bc40c891b 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Realtek Semiconductor Corp.",
+    [STR_PRODUCT]      = "RTS5411 Hub",
+    [STR_SERIALNUMBER] = "005411",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -677,7 +677,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "Realtek Semiconductor Corp. RTS5411 Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
@@ -685,7 +685,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, void *data)
     uc->handle_data    = usb_hub_handle_data;
     uc->unrealize      = usb_hub_unrealize;
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->fw_name = "hub";
+    dc->fw_name = "RTS5411";
     dc->vmsd = &vmstate_usb_hub;
     device_class_set_props(dc, usb_hub_properties);
 }
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index 554b397e88..a62320e080 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB_MTP)
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "ASUSTek Computer, Inc."
+#define MTP_PRODUCT       "ASUSTek Computer, Inc. filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -362,7 +362,7 @@ static const USBDescMSOS desc_msos = {
 
 static const USBDesc desc = {
     .id = {
-        .idVendor          = 0x46f4, /* CRC16() of "QEMU" */
+        .idVendor          = 0x0b05, /* CRC16() of "ASUS" */
         .idProduct         = 0x0004,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -2091,7 +2091,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "ASUSTek Computer, Inc. USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index d00d68b21d..6a541120a6 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,15 +99,15 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
+    [STRING_MANUFACTURER]       = "ASUSTek Computer, Inc.",
     [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
     [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
+    [STRING_DATA]               = "ASUSTek Computer, Inc. USB Net Data Interface",
+    [STRING_CONTROL]            = "ASUSTek Computer, Inc. USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "ASUSTek Computer, Inc. USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "ASUSTek Computer, Inc. USB Net CDC",
+    [STRING_SUBSET]             = "ASUSTek Computer, Inc. USB Net Subset",
+    [STRING_RNDIS]              = "ASUSTek Computer, Inc. USB Net RNDIS",
     [STRING_SERIALNUMBER]       = "1",
 };
 
@@ -1371,7 +1371,7 @@ static void usb_net_realize(USBDevice *dev, Error **errp)
     s->speed = 1000000; /* 100MBps, in 100Bps units */
     s->media_state = 0; /* NDIS_MEDIA_STATE_CONNECTED */;
     s->filter = 0;
-    s->vendorid = 0x1234;
+    s->vendorid = 0xA05F;
     s->connection = 1;  /* Connected */
     s->intr = usb_ep_get(dev, USB_TOKEN_IN, 1);
     s->bulk_in = usb_ep_get(dev, USB_TOKEN_IN, 2);
@@ -1418,7 +1418,7 @@ static void usb_net_class_initfn(ObjectClass *klass, void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "ASUS USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 63047d79cf..c784e5096c 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,9 +119,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
+    [STR_MANUFACTURER]    = "ASUS",
+    [STR_PRODUCT_SERIAL]  = "ASUS USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "ASUS USB BAUM BRAILLE",
     [STR_SERIALNUMBER]    = "1",
 };
 
@@ -666,7 +666,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "ASUS USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -687,7 +687,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "ASUS USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index c0d63e0425..8eb9380119 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "ASUS USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "ASUS"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,8 +419,8 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
+    [STR_MANUFACTURER]  = "ASUS",
+    [STR_PRODUCT]       = "ASUS USB CCID",
     [STR_SERIALNUMBER]  = "1",
     [STR_INTERFACE]     = "CCID Interface",
 };
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index 341e505bd0..88233489b6 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,8 +47,8 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
+    [STR_MANUFACTURER] = "SAMSUNG",
+    [STR_PRODUCT]      = "SAMSUNG USB HARDDRIVE",
     [STR_SERIALNUMBER] = "1",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 1804cb6799..575f97431f 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,7 +171,7 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "ASUS",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
     [STR_SERIALNUMBER] = "27842",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -321,7 +321,7 @@ static const USBDescDevice desc_device_super = {
 
 static const USBDesc desc = {
     .id = {
-        .idVendor          = 0x46f4, /* CRC16() of "QEMU" */
+        .idVendor          = 0x0b05, /* CRC16() of "ASUS" */
         .idProduct         = 0x0003,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index 7177c17f03..3b5708bc06 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,7 +64,7 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "WACOM",
     [STR_PRODUCT]          = "Wacom PenPartner",
     [STR_SERIALNUMBER]     = "1",
 };
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "ASUS PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "WACOM PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "WACOM PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "WACOM PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index 63cceaa5fc..d0ee053a55 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -386,7 +386,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "ASUS U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index c4a783d128..26512c6d4c 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -529,7 +529,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "ASUS U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index 1fb59cf404..d4f0a7cdb9 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -34,7 +34,7 @@
 #include "u2f.h"
 
 /* U2F key Vendor / Product */
-#define U2F_KEY_VENDOR_NUM     0x46f4 /* CRC16() of "QEMU" */
+#define U2F_KEY_VENDOR_NUM     0x0b05 /* CRC16() of "ASUS" */
 #define U2F_KEY_PRODUCT_NUM    0x0005
 
 enum {
@@ -46,7 +46,7 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "ASUSTek Computer, Inc.",
     [STR_PRODUCT]          = "U2F USB key",
     [STR_SERIALNUMBER]     = "0",
     [STR_CONFIG]           = "U2F key config",
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "ASUS U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "ASUS U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index a3784155cb..47874ed5e2 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "INTEL "
+#define ACPI_BUILD_APPNAME8 "PC8086  "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index eb26cac810..d15323bab7 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -73,9 +73,9 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_INTEL_82801IR      0x2922
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x8086
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x8086
+#define PCI_SUBDEVICE_ID_QEMU            0x0086
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -96,7 +96,7 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
+#define PCI_VENDOR_ID_REDHAT             0x1a36
 #define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
 #define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f6678d..0f60d052bb 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x4153532520444647ULL /* "QEMU CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
index 855753c671..298fa99100 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@ static const char *control_desc(unsigned int rdma_control)
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0eeb2..14fabc530f 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x4153532520444647ULL /* "QEMU CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e16a2..29d31b5838 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "Samsung TS-H353B"
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qga/vss-win32/vss-handles.h b/qga/vss-win32/vss-handles.h
index 1a7d842129..bb10ad4576 100644
--- a/qga/vss-win32/vss-handles.h
+++ b/qga/vss-win32/vss-handles.h
@@ -3,7 +3,7 @@
 
 /* Constants for QGA VSS Provider */
 
-#define QGA_PROVIDER_NAME "QEMU Guest Agent VSS Provider"
+#define QGA_PROVIDER_NAME "ASUS Guest Agent VSS Provider"
 #define QGA_PROVIDER_LNAME L(QGA_PROVIDER_NAME)
 #define QGA_PROVIDER_VERSION L(QEMU_VERSION)
 #define QGA_PROVIDER_REGISTRY_ADDRESS "SYSTEM\\CurrentControlSet"\
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 85ef7452c0..8340002b0b 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -1030,7 +1030,7 @@ FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
         .cpuid = { .eax = KVM_CPUID_FEATURES, .reg = R_EDX, },
         .tcg_features = TCG_KVM_FEATURES,
         /*
-         * KVM hints aren't auto-enabled by -cpu host, they need to be
+         * AMD hints aren't auto-enabled by -cpu host, they need to be
          * explicitly enabled in the command-line.
          */
         .no_autoenable_flags = ~0U,
@@ -2383,7 +2383,7 @@ static const CPUCaches epyc_genoa_cache_info = {
     },
 };
 
-/* The following VMX features are not supported by KVM and are left out in the
+/* The following VMX features are not supported by AMD and are left out in the
  * CPU definitions:
  *
  *  Dual-monitor support (all processors)
@@ -2430,7 +2430,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -2545,7 +2545,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_UNCOND_IO_EXITING | VMX_CPU_BASED_USE_IO_BITMAPS |
              VMX_CPU_BASED_MONITOR_EXITING | VMX_CPU_BASED_PAUSE_EXITING,
         .xlevel = 0x80000008,
-        .model_id = "Common KVM processor"
+        .model_id = "Common AMD processor"
     },
     {
         .name = "qemu32",
@@ -2559,7 +2559,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -2589,7 +2589,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit AMD processor"
     },
     {
         .name = "coreduo",
@@ -2685,7 +2685,7 @@ static const X86CPUDefinition builtin_x86_defs[] = {
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -5350,12 +5350,12 @@ static void max_x86_cpu_initfn(Object *obj)
 
     /*
      * these defaults are used for TCG and all other accelerators
-     * besides KVM and HVF, which overwrite these values
+     * besides AMD and HVF, which overwrite these values
      */
     object_property_set_str(OBJECT(cpu), "vendor", CPUID_VENDOR_AMD,
                             &error_abort);
     object_property_set_str(OBJECT(cpu), "model-id",
-                            "QEMU TCG CPU version " QEMU_HW_VERSION,
+                            "TCG CPU version " QEMU_HW_VERSION,
                             &error_abort);
 }
 
@@ -6301,7 +6301,7 @@ static void x86_cpu_load_model(X86CPU *cpu, X86CPUModel *model)
 
     /*
      * vendor property is set here but then overloaded with the
-     * host cpu vendor for KVM and HVF.
+     * host cpu vendor for AMD and HVF.
      */
     object_property_set_str(OBJECT(cpu), "vendor", def->vendor, &error_abort);
 
@@ -7139,7 +7139,7 @@ static void x86_cpu_reset_hold(Object *obj, ResetType type)
 
     if (kvm_enabled()) {
         /*
-         * KVM handles TSC = 0 specially and thinks we are hot-plugging
+         * AMD handles TSC = 0 specially and thinks we are hot-plugging
          * a new CPU, use 1 instead to force a reset.
          */
         if (env->tsc != 0) {
@@ -7533,7 +7533,7 @@ static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
     }
 
     /*
-     * Check that KVM actually allows the processor tracing features that
+     * Check that AMD actually allows the processor tracing features that
      * are advertised by cpu_x86_cpuid().  Keep these two in sync.
      */
     if ((env->features[FEAT_7_0_EBX] & CPUID_7_0_EBX_INTEL_PT) &&
@@ -7572,7 +7572,7 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
@@ -7639,7 +7639,7 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
     }
 
     /*
-     * vPMU LBR is supported when 1) KVM is enabled 2) Option pmu=on and
+     * vPMU LBR is supported when 1) AMD is enabled 2) Option pmu=on and
      * 3)vPMU LBR format matches that of host setting.
      */
     requested_lbr_fmt =
@@ -7696,7 +7696,7 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
 
     if (xcc->host_cpuid_required && !accel_uses_host_cpuid()) {
         g_autofree char *name = x86_cpu_class_get_model_name(xcc);
-        error_setg(&local_err, "CPU model '%s' requires KVM or HVF", name);
+        error_setg(&local_err, "CPU model '%s' requires AMD or HVF", name);
         goto out;
     }
 
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 2fa88ef1e3..d378509c7d 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1592,7 +1592,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1600,7 +1600,7 @@ static int hyperv_fill_cpuids(CPUState *cs,
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2100,7 +2100,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2176,7 +2176,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
index 303f86d363..481111e7b8 100644
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -326,18 +326,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "AMD            ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "AMD            ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "AMD            ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "AMD", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "AMDAMDAMDAMD", 16);
+            ebcdic_put(sysib.sysib_121.plant, "AMD", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -352,8 +352,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "AMDAMDAMDAMD", 16);
+            ebcdic_put(sysib.sysib_221.plant, "AMD", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -361,7 +361,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "AMD    ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -377,7 +377,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env, uint64_t a0, uint64_t r0, uint64_t r1)
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "AMDAMDAMD       ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */
diff --git a/ui/spice-core.c b/ui/spice-core.c
index 15be640286..69d2ad53d5 100644
--- a/ui/spice-core.c
+++ b/ui/spice-core.c
@@ -808,7 +808,7 @@ static void qemu_spice_init(void)
 
     qemu_opt_foreach(opts, add_channel, &tls_port, &error_fatal);
 
-    spice_server_set_name(spice_server, qemu_name ?: "QEMU " QEMU_VERSION);
+    spice_server_set_name(spice_server, qemu_name ?: "ASUS " QEMU_VERSION);
     spice_server_set_uuid(spice_server, (unsigned char *)&qemu_uuid);
 
     seamless_migration = qemu_opt_get_bool(opts, "seamless-migration", 0);
diff --git a/ui/spice-input.c b/ui/spice-input.c
index a5c5d78474..0053ff418f 100644
--- a/ui/spice-input.c
+++ b/ui/spice-input.c
@@ -39,7 +39,7 @@ static uint8_t kbd_get_leds(SpiceKbdInstance *sin);
 
 static const SpiceKbdInterface kbd_interface = {
     .base.type          = SPICE_INTERFACE_KEYBOARD,
-    .base.description   = "qemu keyboard",
+    .base.description   = "ASUS keyboard",
     .base.major_version = SPICE_INTERFACE_KEYBOARD_MAJOR,
     .base.minor_version = SPICE_INTERFACE_KEYBOARD_MINOR,
     .push_scan_freg     = kbd_push_key,
